# sm3的长度扩展攻击实现说明
本项目实现的是sm3的长度扩展攻击
为了实现sm3算法，本项目采用的是gmssl库中对于sm3的实现，即sm3.py。并且在进行长度扩展攻击时对原sm3算法的实现进行了一些修改，使得能够按照不同于IV的初始向量进行运算，即mysm3.py
为了能够成功运行该代码，需要将我们的mysm3.py文件与攻击代码放在同一目录下并导入。

项目的实现总共分为三个大的步骤：
1. 我们随机生成一个消息message作为原始的秘密内容，我们使用正常的sm3加密对其进行哈希运算，得到一个哈希值old_hash
2. 我们生成我们想要添加的内容add，并且按照固定的规则将原消息进行填充，再加上我们想要添加的内容add，得到一个新的内容message+padding+add，将这个整体再次通过完整的原始sm3算法进行运算，这样会得到一个新的哈希值new_hash
3. 我们编写进行长度扩展攻击的部分，已知原消息长度的情况下伪造原消息m'并将其进行相同的填充，将m'+padding+add进行伪造签名得到一个伪造的哈希值forged_hash。如果我们的攻击是成功的，则forged_hash应该与new_hash一致。

根据长度扩展攻击的原理，为了方便实现，我们将添加的内容add的长度设定在一个消息分块的长度之内，即64-8=56字节以内。

关于对sm3的修改，将sm3hash函数新增了一个参数，使其能够接收新的链变量而非只能默认使用初始向量IV。运算轮数也根据我们上面的规定二设定为只进行最后一轮的运算。

攻击部分编写包括填充函数和伪造签名（攻击）函数，对其进行简单的说明：填充函数padding负责将输入的字符串进行合法填充得到长度为64字节整数倍的填充字符串。伪造签名函数的功能是根据消息长度进行伪造消息，并根据old_hash的值设置新的链变量，再通过mysm3进行计算哈希值。下面是供给部份两个函数：

执行时我们默认秘密消息为一个字符串，内容为“length extend attack”与执行时日期的级联。最终实验结果可以验证我们对于sm3的长度扩展攻击是成功的。

![1658373062048](https://user-images.githubusercontent.com/105530561/180121799-c0182d64-7ed4-4d80-be80-e03886accc8c.png)

对于sm3实现的修改部分
![EYL2 2%B93W_FF(05}{0S7K](https://user-images.githubusercontent.com/105530561/180123848-b9fc98ea-da7a-4426-afd3-01210680cf9d.png)

